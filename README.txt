Ask:
1. Can we have the RemoteObjectReference.class in the client's classpath?

AB:
1. ZipCodeServer does not extend remote. Only RemoteObjectReference does? --> our implementation is a bit
	different, but ZipCodeServer might as well extend the remote interface in order to check if it itself
	can be provided as a service.
2. There is no need to Msg_type in the clientrmimsg because we send it only from client to server, and
	only for rmi, not for getRegistry. Also, the server should not have this class because the server
	sends a return value, or the reference object as a single object, and does not need to be wrapped in clientmsgrmi.
	
	
Communication: 
1. No need to send client hostname and port because server can get it from the accepted socket connection. 
	i. socket.getPort() gives the port of the other guy.
	socket.getLocalPort() gives your own port.
	ii. also, socket.getInetAddress().getHostName() gives the other guy's hostname.
	
	
TODOs:
---1. check for null for all values returned by helper or stub in all client and server classes.
---2. All objects which implement “Remote” are passed by reference. Other objects are passed by value (serialized)
---3. make server_impl methods synchronized
---4. what about objects passed by reference by the client?
---5. rebind and unbind
---6. check where to close streams (on client), and where to shutdown (on server) them
7. when initializing the server, ask for the address of the machine that the server is running on. this is for 
	embedding this address in the ROR for the client to send the request to.
---8. check that we are not importing any java.rmi classes/methods by mistake in any of the classes.
---9. handle all exceptions (TODO stubs)
10. go through all the remaining TODOs
---11. check in registryservice if the object sent by server implements Remote. if not, send back false for bind and rebind
---12. Check that all public methods of remote objects throw remote exception. Do this while initialising the remote object.
---13. comment code
14. finish report
15. Notes: 1. we assume that user knows the service name (interface name) used to bind in the registry. 
16. create the README with execution instructions
	
Remote Exceptions:
Any exception that is possible in the logic of the application programmer needs to be thrown in the interface, e.g. ZipCodeServer.
Such an exception will be "thrown" by ZipCodeServer_Impl and caught by RemoteObjThread. It will then be conveyed to 
ZipCodeServer_stub which will "throw" it back to the client.
However, any exception generated by ZipCodeServer_Impl is also a remote exception, and is conveyed to ZipCodeServer_stub, but
it cannot throw it to the client, because the client's program did not generate the exception. In such cases, the stub has
to print the error message and let the client know that something went wrong on the server side. Depending on the class of the
exception, the stub may decide to terminate the client process (but we do not implement this functionality). 
The stub will know which exception to throw and which not to by using the definition of the method that it is currently running.
That is, if the method defined in ZipCodeServer throws an exception (general Exception, or RemoteException), then the stub throws
it as well.
--Update: since we don't have a remote object that has an execute method through which we execute the client's code,
the client's methods have to throw RemoteException so that the client can decide what to do with it. Now, if the client code
actually throws some exception, it can be caught by the ZipCodeServer_Impl on the server side, and wrapped into a RemoteException.
So, in the interface, ZipCodeServer, each method has to throw RemoteException. If it also throws some other exception, then it can
generalize and throw Exception. In that case, it will still be wrapped into a RemoteException by ZipCodeServer_Impl and sent 
to the stub on the client side. On the client side, it will still be returned as a RemoteException and it is the client's job
to check if it is actually the other exception that it's method throws, or is it some RemoteException only. There has to be a better
way to distinguish between the two, but we have not accounted for that.
We can do something similar for the LocateSimpleRegistry.getRegistry() method and the lookup method in SimpleRegistry, but we
are not doing that in our implementation. The stub for LocateSimpleRegistry and the SimpleRegistry resp. handle the exceptions.
The client only has to check for null return values from these local methods. 

RemoteException thrown by an _Impl method will be caught as an InvocationTargetException in RemoteObjThread.
So we wrap it again as a RemoteException -->improve?
